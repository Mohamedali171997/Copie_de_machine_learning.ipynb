# -*- coding: utf-8 -*-
"""Copie de machine learning

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fmTAur9SGhAOcRQznM5d_A-R8FN-AElj



**importation de bibliotheque**
"""

import numpy as np
import pandas as pd
import nltk 
from nltk.corpus import stopwords
import string

"""**importation de base de donne**"""

from google.colab import files
uploadede =files.upload()
#emails.csv

"""**ouverture de fichier**"""

df =pd.read_csv('emails.csv')
df.head(5)
df.shape

"""**elemination de colonne** *'Email No.'*"""

df1 =df.loc[:, df.columns != 'Email No.']
print(df1)

"""**elemination des doublon** (case contiant meme valeur)
cette operation est optionelle
"""

#check for duplicate and remove them
df1.drop_duplicates(inplace =True)

"""**nouveau format de base de donne**"""

#show the new shape(number of row and columns )
df1.shape

"""**replacer le valeur NaN Par 0**"""

# Repalce NaN with zero on all columns 
df2 = df1.fillna(0.0)
df3= df2.replace(r'^\s*$', 0.0, regex=True)
print(df3)

"""**voici combient de (NAN,NaN,na) pour chaque colonne** operation optionnelle"""

#show the number of missing (NAN,NaN,na)data for each column
df3.isnull().sum()

"""**netoyage le base de caractere pseudo-bizare**

*exemple*

(B ъ ь в ɓ ฿ β ß Ɓ 乃 ⓑ Ⓑ [B] Β β ъ ь в ฿ Ъ Ь)
1.   elemination de ponctuation 
2.   elemination de StopWord
3.   return list de mot propre

On utiliant StopWords Package 





"""

#download the stopwords package
nltk.download('stopwords')
def process_text(text):
  #1remove punctuation
  #2remove stopwords
  #return a list of clean text words
  #1
  nopunc =[char for char in text if char not in string.punctuation]
  nopunc = ''.join(nopunc)
  #2
  clean_words =[words for words in nopunc.split() if word.lower() not in stopwords.words('english')]
  #3
  return clean_words

dataset = df3.values

print(df3)
df.shape

"""**deviser le dataframe en data et target**"""

x=df3.data
y=df3.target
df3.type



"""**deviser les donner en 75% training et 25% test**"""

from re import X
#split data into 75 training 25 test
from sklearn.model_selection import train_test_split
x_train,x_test,y_train,y_test=train_test_split(dataset,df2['Prediction'],test_size=0.25,random_state=0)

df3['Prediction'].shape
#dataset.shape

"""**Algorithme de KNN (K – Nearest Neighbor)**

 L’algorithme des K plus proches voisins ou K-nearest neighbors (kNN) est un algorithme de Machine Learning qui appartient à la classe des algorithmes d’apprentissage supervisé simple et facile à mettre en œuvre qui peut être utilisé pour résoudre les problèmes de classification et de régression. Dans cet article, nous allons revenir sur la définition de cet algorithme, son fonctionnement ainsi qu’une application directe en programmation
"""

from sklearn.neighbors import KNeighborsClassifier
model=KNeighborsClassifier(n_neighbors=3,weights='distance')
model.fit(x_train,y_train)
from sklearn.metrics import confusion_matrix
import seaborn as sns
print('Train score :',model.score(x_train,y_train))

"""**créer et entraîner le classificateur naïf bayes**"""

#x_train.reshape(1, -1)
#create and train the naive bayes classifier

from sklearn.naive_bayes import MultinomialNB
classifier = MultinomialNB().fit(x_train, y_train)

"""**resultat de predection**"""

#print the predictions
print(classifier.predict(x_train))
#print the actual values
print(y_train.values)
print(y_train)

"""**evaluation de model**"""

#evaluate the model on the training data set
from sklearn.metrics import classification_report,confusion_matrix,accuracy_score
pred = classifier.predict(x_train)
print(classification_report(y_train,pred))
print('Confusion Matrix : \n',confusion_matrix(y_train,pred))
print('Accuracy:',accuracy_score(y_train,pred))

"""**affichage de prediction et le valeur reel**"""

#print the predictions
print(classifier.predict(x_test))
#print the actual values
print(y_test.values)

"""**evaluation de model**"""

#evaluate the model on the training data set
from sklearn.metrics import classification_report,confusion_matrix,accuracy_score
pred = classifier.predict(x_test)
print(classification_report(y_test,pred))
print('Confusion Matrix : \n',confusion_matrix(y_test,pred))
print('Accuracy:',accuracy_score(y_test,pred))

"""**affichage de diagrame**"""

from sklearn.model_selection import train_test_split
#x_train,x_test,y_train,y_test=train_test_split(x,y,test_size=0.25,random_state=4,stratify=y)
print('train set',x_train.shape)
print('test_set',x_test.shape)
from sklearn.neighbors import KNeighborsClassifier
model=KNeighborsClassifier(n_neighbors=3,weights='distance')
model.fit(x_train,y_train)
from sklearn.metrics import confusion_matrix
import seaborn as sns
print('Train score :',model.score(x_train,y_train))

CM_train=confusion_matrix(y_train,model.predict(x_train))
sns.heatmap(CM_train,square=True,annot=True,cbar=False,xticklabels=list(df3.target),yticklabels=list(df3.data))

print('Test score :',model.score(x_test,y_test))
CM_test=confusion_matrix(y_test,model.predict(x_test))
sns.heatmap(CM_test,square=True,annot=True,cbar=False,xticklabels=list(df3.target),yticklabels=list(df3.target))